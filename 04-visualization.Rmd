---
title: "Reproducibility Dashboard"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
editor_options: 
  
  chunk_output_type: console
  
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = 'index.html',
      envir = globalenv()
    )
  })
---

```{r setup_02, include=FALSE}
library(flexdashboard)
library(shiny)
library(tidyverse)
library(stringdist)       
library(readr)
library(knitr)
library(viridisLite)
library(highcharter)
library(plotly)

knit("./03-data-filtering.Rmd")
```

## Column

### Reproductions

```{r asd}
reproductions <- length(unique(c(claims_df$reproduction_id,abandoned_df$reproduction_id))) #claims instead of dis because some have all NA repro scores
valueBox(reproductions, icon = "fa-pencil")
```

### Papers

```{r asd1}
papers <-  length(unique(c(claims_df$similar_title,abandoned_df$similar_title)))
valueBox(papers, icon = "fa-file")
```

### Claims
```{r asd2}
claims <- claims_df %>% mutate("claim_id" = paste0(similar_title, claim_N)) %>% summarise( length( unique(claim_id)) ) %>% as.numeric()
valueBox(claims, icon = "fa-comment")
```

## Row {.tabset data-height="500"}

```{r histogram function}
# This function takes a dataframe, groups it by a list of variables, applies a function to summarize the reproducibility (possibly weighted by a variable), and then iteratively ungroups until it produces a paper-level summary. 

# The argument `vars` is the vector of variables to group by listed in order from coarsest (i.e. smallest number of unique values) to finest (i.e. largest number of unique values)

# fns is a list of functions to do aggregation (e.g. mean) in the order they should be applied

# w is a column to use as weights

paper_hist <- function(df, vars, fns, w=NULL){
    n_ungroup <- length(vars)
    stat1 <- df %>% 
        group_by(across(vars)) %>%
        summarise(paper_level = fns[[1]](repro_score,w=w))
    if (length(vars)>1){
        for (i in c(0:(length(vars)-2))){
            
        stat1 <- stat1 %>%
            ungroup(vars[length(vars)-i]) %>%
            summarise(paper_level=fns[[i+2]](paper_level,w=w))
    }
    }
    
    
    level_max <- stat1 %>%
    mutate(paper_level=floor(paper_level)) %>%
    group_by(paper_level) %>%
    summarize(n = n()) %>%
    max()

    out <- stat1 %>% 
        ggplot(aes(x = paper_level)) +
        geom_histogram(binwidth = 1,
                       color = "black",
                       fill = "gray") +
        coord_cartesian(ylim =  c(0, 1.1*level_max)) +
        scale_x_continuous(breaks = 1:10) +
        theme(panel.background = element_rect(fill="white"),
          panel.grid.major.y = element_line(color="grey80"),
          panel.grid.minor.y = element_line(color="grey80"),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank())
    return(out)
}

```

### Levels of Reproducibility
```{r}
paper_hist(dis_df, c("similar_title","reproduction_id"),list(mean,mean))+
    labs(title = "Distribution of Reproduction Scores: Paper Level",
             x = "Reproducibility Score",
             y = "Count")
```


### Abandoned Included
```{r}
abandoned_scores <- abandoned_df %>%
    select(similar_title,reproduction_id) %>%
    mutate(repro_score=1)

dis_aband <- rbind.data.frame(
    select(dis_df,similar_title,reproduction_id,repro_score),
    abandoned_scores
    )

paper_hist(dis_aband,c("similar_title","reproduction_id"),list(mean,mean))+
    labs(title = "Distribution of Reproduction Scores: Paper Level",
             x = "Reproducibility Score",
             y = "Count")
```

### Max within paper
```{r}
paper_hist(dis_df,c("similar_title"),list(max))+
    labs(title = "Distribution of Maximum Reproduction Scores: Paper Level",
             x = "Reproducibility Score",
             y = "Count")

```

### Min within paper
```{r}
paper_hist(dis_df,c("similar_title"),c(min))+
    labs(title = "Distribution of Minimum Reproduction Scores: Paper Level",
             x = "Reproducibility Score",
             y = "Count")

```

### Summary of Levels

| Level | Short summary                      |
|:-----:|:----------------------------------:|
| 1     | No Data or Code                    |
| 2     | Only Code                          |
| 3     | Partial analysis data & code       |
| 4     | All analysis data & code           |
| 5     | Reproducible from analysis data    |
| 6     | All cleaning code + L4             |
| 7     | Some raw data     + L6             |
| 8     | All cleaning code and raw data     |
| 9     | Reproducible from analysis  + L8   |
| 10    | Reproducible from raw data         |

For a more comprehensive description of the levels of computational reproducibility, see the [ACRe Guide](https://bitss.github.io/ACRE/assessment.html#levels-of-computational-reproducibility-for-a-specific-display-item)

## Row {data-height="500"}

### Reproducers Around the World

```{r map,   fig_width = 15, fig_height = 7.6, fig_retina = 2}
library(rnaturalearth)
library(rgeos)
library(RColorBrewer)

#get number of reproductions by country
country_counts <- dis_df %>% 
  group_by(reproduction_id) %>% 
  slice(1) %>%
  group_by(country_code) %>% 
  count %>% 
  rename(postal = country_code)

world <- ne_countries(returnclass = "sf",scale="small") %>%
    filter(admin!="Antarctica")
#merge to the world data 
world <- left_join(world, country_counts, by=c("postal")) %>% 
  mutate(n =  ifelse(is.na(n), 0, n))

# Make bins
breaks <- quantile(unique(world$n),
                   probs = seq(0,1,0.25))

world$breaks <- cut(world$n,
        breaks = breaks,
        include.lowest = TRUE,
        labels=F)
#world$breaks <- as.character(world$breaks)

world$text <- paste0(world$admin,"\nReproductions: ",world$n)
world$n[world$n==0] <- NA # To make them stand out on map

# light grey boundaries
l <- list(color = toRGB("grey"), width = 0.5)
g <- list(
  showframe = FALSE,
  showcoastlines = FALSE,
  projection = list(type = 'Mercator')
)

fig <- ggplot(data=world)+
    geom_sf(aes(fill=n, text=text, color = admin),
            size=0)+
    scale_fill_distiller(palette="YlGnBu",direction = 1,
                         name="Reproductions") +
    theme(panel.background = element_blank(),
          axis.ticks = element_blank(),
          axis.text = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()
          )

# Workaround for getting hover over polygons:
# https://github.com/plotly/plotly.R/issues/1641#issuecomment-550477069

fig <- ggplotly(fig,
                tooltip="text") 

fig <- fig %>%
    style(hoverlabel = list(bgcolor = "white"),
          hoveron="fills",
          line.color="grey60",
          traces = seq.int(2, length(fig$x$data))
          ) %>%
    hide_legend() %>%
    layout(xaxis = list(autorange = TRUE),
         yaxis = list(autorange = TRUE))

fig
```


<!--
### Universities  

| University | Number of Reproductions |
|:-------------------:|:------:|
| UC Berkeley         | `r reproductions`      |
|                     |        |
|                     |        |

-->


